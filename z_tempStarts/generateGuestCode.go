package main

import (
	"bufio"
	"fmt"
	"log"
	"math/rand"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/sea350/ustart_go/middleware/client"

	post "github.com/sea350/ustart_go/post/guestCode"
	"github.com/sea350/ustart_go/types"
)

func isInt(input string) bool {
	if _, err := strconv.Atoi(input); err != nil {
		fmt.Println(input)
		return false
	}
	return true
}

const letterBytes = "ABCDEFGHJKLMNPQRSTUVWXYZ1234567890"

func randStringBytes(n int) string {
	b := make([]byte, n)
	for i := range b {
		b[i] = letterBytes[rand.Intn(len(letterBytes))]
	}
	return string(b)
}

func dateIsValid(date []string) bool {
	if len(date) == 3 {
		if len(date[0]) == 2 && len(date[1]) == 2 && len(date[2]) == 4 {
			if isInt(date[0]) && isInt(date[1]) && isInt(date[2]) {
				return true
			}
		}
	} else if len(date) == 0 {
		return true
	}
	return false
}

func main() {

	reader := bufio.NewReader(os.Stdin)
	fmt.Print("Enter New Code (leave empty if you want an autogenerated code): ")
	newCode, _ := reader.ReadString('\n')
	newCode = newCode[:len(newCode)-1]
	if newCode == "" {
		//Autogenerate code
		newCode = randStringBytes(8)
	}

	//Take in description
	fmt.Print("Enter Description: ")
	newDesc, _ := reader.ReadString('\n')
	//remove newline from end
	newDesc = newDesc[:len(newDesc)-1]

	//Take in number of uses and checks if it's an integer
	var intNumUses int
	fmt.Print("Enter Number of uses (leave empty if there are unlimited number of uses): ")
	numUses, _ := reader.ReadString('\n')
	numUses = numUses[:len(numUses)-1]
	if numUses != "" {
		for !isInt(numUses) {
			fmt.Print("You did not enter a number, please try again: ")
			numUses, _ = reader.ReadString('\n')
			numUses = numUses[:len(numUses)-1]
			if numUses == "" {
				break
			}
		}
		intNumUses, err := strconv.Atoi(numUses)
		if intNumUses == 0 {
		}
		if err != nil {
			log.SetFlags(log.LstdFlags | log.Lshortfile)
			log.Println(err)
		}
	}

	//Take in expiration date
	fmt.Print("Enter Expiration date in MM/DD/YYYY format (leave empty if code does not expire): ")
	expiration, _ := reader.ReadString('\n')
	expiration = expiration[:len(expiration)-1]

	date := strings.Split(expiration, "/")
	var dateTime time.Time
	if expiration == "" {
		dateTime = time.Date(6000, time.Month(1), 1, 1, 1, 1, 1, time.UTC)
	} else {
		for !dateIsValid(date) {
			fmt.Print("Date is in an improper format, enter a valid format or leave blank:")
			expiration, _ = reader.ReadString('\n')
			expiration = expiration[:len(numUses)-1]
			if expiration == "" {
				break
			} else {
				date = strings.Split(expiration, "/")
			}
		}
		if expiration != "" {
			year, _ := strconv.Atoi(date[2])
			month, _ := strconv.Atoi(date[0])
			day, _ := strconv.Atoi(date[1])
			dateTime = time.Date(year, time.Month(month), day, 1, 1, 1, 1, time.UTC)
		}
	}

	//Use magic regex to check format of expiration date

	var classification int

	switch {
	case numUses == "" && expiration == "":
		classification = 0 //permanent
	case numUses != "" && expiration == "":
		classification = 1 //limited uses, no expiration
	case numUses == "" && expiration != "":
		classification = 2 //unlimited uses, expiration
	case numUses != "" && expiration != "":
		classification = 3 //limited uses, expiration
	}

	fmt.Println("newCode: ", newCode)
	fmt.Println("newDesc: ", newDesc)
	fmt.Println("numUses: ", intNumUses)
	fmt.Println("expiration: ", dateTime)
	fmt.Println("classification: ", classification)

	newGuestCode := types.GuestCode{Code: newCode, Description: newDesc, NumUses: intNumUses, Classification: classification, Expiration: dateTime}
	_, err := post.IndexGuestCode(client.Eclient, newGuestCode)
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println("Success!")
	}

}
